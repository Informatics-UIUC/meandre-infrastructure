/**
 * ZigZag javaCC parser definition.
 * 
 * This parser describes the grammer and the basic compilation mechanisms of  
 * Meandre's ZigZag scripting language.
 *
 * @author Xavier Llora
 */
 
options {
  JDK_VERSION = "1.5"; 
  STATIC = false;
}
PARSER_BEGIN(ZigZag)
package org.meandre.zigzag.parser;

import java.io.*;
import java.util.*;
import org.meandre.zigzag.semantic.*;
import java.util.logging.*;
import org.meandre.core.logger.KernelLoggerFactory;

public class ZigZag {

  public static String ZIGZAG_VERSION = "1.0.1vcli";
  
  protected String sFileName;
  
  protected FlowGenerator fg;
  
  public void setFileName(String fname){
	this.sFileName = fname;
  }

  public String getFileName(){
	return this.sFileName;
  }

  public void initFlowGenerator(){
    this.fg = new FlowGenerator();
  }

  public void setFlowGenerator ( FlowGenerator fg ) {
  	this.fg = fg;
  }

  public FlowGenerator getFlowGenerator(){
   return this.fg;
  }
  
  public static void main(String args[]) throws ParseException,FileNotFoundException, IOException {
    
    // Tone down the logger
	KernelLoggerFactory.getCoreLogger().setLevel(Level.WARNING);
	for ( Handler h:KernelLoggerFactory.getCoreLogger().getHandlers() )
		h.setLevel(Level.WARNING);
		
    if ( args.length<1 ) {
    	System.err.println("Wrong syntax!!!\nThe compiler requires at least on .zz file");
    }
    else
    {
    	for ( String sFileName:args) {
		    FileInputStream fis = new FileInputStream(sFileName);
		    ZigZag parser = new ZigZag(fis);    
		    parser.sFileName = sFileName;
		    parser.fg = new FlowGenerator();
		    try {
		    	parser.start(); 
		    	System.out.println();
		    	parser.fg.generateMAU(sFileName); 
		    }
		    catch ( ParseException pe ) {
		    	throw pe;
		    } 
    	}
    }
  }
}
PARSER_END(ZigZag)

SKIP :
{
 	" "
|	"\r"
|	"\t"
|	"\n"
|	"\f"
}

SKIP :
{
  <"#" (~["\n","\r"])* ["\n","\r"]>
}

TOKEN : 
{
	< COMA: "," >
|	< EQUAL: "=" >
|	< LP: "(" >
|	< RP: ")" >
|	< DOT: "." >
|	< COLON: ":" >
|	< SEMICOLON: ";" >
|	< AT: "@" >
|	< LB: "[" >
|	< RB: "]" >
|	< PLUS: "+" > 
|	< EXCL: "!" >
}
TOKEN : 
{
	< IMPORT: "import">
|   < FROM: "from"> 
|   < ALIAS: "alias"> 
|   < AS: "as">
|   < AUTO: "AUTO">
|   < NUMBER: ["1"-"9"](["0"-"9"])* >
}
TOKEN :
{ 
    < SYMBOL: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9","-","_"] )* >
|	< URI: "<" (["a"-"z","A"-"Z"])+ "://"(["a"-"z","A"-"Z","0"-"9"," ","-","_",":","/","%","+","&","=",".","@"])+ ">" >
|	< VALUE: "\"" (~["\""])* "\"" >
}
void start() : 
{
	Token t;
} 
{
	{ fg.init(sFileName); }
  	(
  		cda() 
	| 	t=<SYMBOL> (ci(t) | cm(t) | ii_call(t) ) 
	|	ii_assigment()
  	)*
  	<EOF>
}

void cda() : 
{
	Token tRepURI;
	Token tCompURI;
	Token tAlias;
} 
{
	( 
		<IMPORT>
		tRepURI=<URI> 
		{ fg.importRepository(tRepURI.image,jj_input_stream.getBeginLine()-1); }	
	) |
	( 
		<ALIAS>
		tCompURI=<URI>
		<AS>
		tAlias = <SYMBOL> 
		{ fg.aliasCoponent(tCompURI.image,tAlias.image,jj_input_stream.getBeginLine()-1);}
	) |
	( 
		<FROM>
		tRepURI=<URI>
		<IMPORT>
		tCompURI=<URI>
		{ fg.importRepository(tRepURI.image,tCompURI.image,jj_input_stream.getBeginLine()-1); }
		(
			<AS>
			tAlias = <SYMBOL>
			{ fg.aliasCoponent(tCompURI.image,tAlias.image,jj_input_stream.getBeginLine()-1);}
		)? 
	)
}

void ci(Token t) : 
{
	Token tTmp;
	Queue<String> qSymbols = new LinkedList<String>();
	Queue<String> qComponents = new LinkedList<String>();
	qSymbols.offer(t.image);
}
{
	( 
		<COMA> 
		tTmp=<SYMBOL> 
		{ qSymbols.offer(tTmp.image); }
	)* 
	<EQUAL> 
	tTmp=<SYMBOL> <LP><RP> 
	{ qComponents.offer(tTmp.image); }
	(
		<COMA>
		tTmp=<SYMBOL> <LP><RP>
		{ qComponents.offer(tTmp.image); }
	)*
	{
		if ( qSymbols.size()!=qComponents.size() )
			throw new ParseException ( 
				"Wrong number of elements in assigment, "+
				qSymbols.size()+" on the left side and "+
				qComponents.size()+" on the right side on line "+
				(jj_input_stream.getBeginLine()-1)
			);
		fg.instantiateComponents(qSymbols,qComponents,jj_input_stream.getBeginLine()-1);
	}
}

void cm(Token t) : 
{
	Token tIns;
	Token tProp;
	Queue<String> qLeftIns = new LinkedList<String>();
	Queue<String> qLeftProp = new LinkedList<String>();
	Queue<String> qRightIns = new LinkedList<String>();
	Queue<String> qRightProp = new LinkedList<String>();
	
	qLeftIns.offer(t.image);
}
{
	<DOT> tProp=<SYMBOL>
	{ qLeftProp.offer(tProp.image); }
	( 
		<COMA> 
		tIns=<SYMBOL> <DOT> tProp=<SYMBOL>
		{ qLeftIns.offer(tIns.image); qLeftProp.offer(tProp.image); }
	)* 
	<EQUAL> 
	(
		tIns=<VALUE> 
		{ qRightIns.offer(tIns.image); qRightProp.offer(null); } 
		|
		tIns=<SYMBOL> <DOT> tProp=<SYMBOL>
		{ qRightIns.offer(tIns.image); qRightProp.offer(tProp.image); }
	)
	(
		<COMA>
		(
			tIns = <VALUE> 
			{ qRightIns.offer(tIns.image); qRightProp.offer(null); }
			|
			tIns=<SYMBOL> <DOT> tProp=<SYMBOL>
			{qRightIns.offer(tIns.image); qRightProp.offer(tProp.image);}
		)
	)*
	{
		if ( qLeftIns.size()!=qRightIns.size() )
			throw new ParseException ( 
				"Wrong number of elements in component modification assigment, "+
				qLeftIns.size()+" on the left side and "+
				qRightIns.size()+" on the right side on line "+
				(jj_input_stream.getBeginLine()-1)
			);
			
		fg.setProperties(qLeftIns,qLeftProp,qRightIns,qRightProp,jj_input_stream.getBeginLine()-1);
	}
}

void ii_call( Token tCall ) : 
{
	Token tParallel;
}
{
	<LP>
		(port_binding(tCall)
			(
				<SEMICOLON>
				port_binding(tCall)
			)*
		)*		
	<RP>
	(
		<LB><PLUS>(
		<AUTO>
		{ fg.markParallel(tCall.image,0); }
		|
		tParallel = <NUMBER>
		{ fg.markParallel(tCall.image,Integer.parseInt(tParallel.image)); }
		)
		(
			<EXCL>
			{ fg.forceOrderedParallel(tCall.image); }
		)?
		<RB>
	)*
}
 
void port_binding( Token tTargetIns ) : 
{
	Token tTargetPort;
	Token tSourceIns;
	Token tSourcePort;
}
{
	tTargetPort=<SYMBOL>
	<COLON>
	tSourceIns=<SYMBOL> <DOT> tSourcePort=<SYMBOL>
	{ fg.bindPort(tSourceIns.image,tSourcePort.image,tTargetIns.image,tTargetPort.image,jj_input_stream.getBeginLine()-1); }
	(	
		<COMA>
		tSourceIns=<SYMBOL> <DOT> tSourcePort=<SYMBOL>
		{ fg.bindPort(tSourceIns.image,tSourcePort.image,tTargetIns.image,tTargetPort.image,jj_input_stream.getBeginLine()-1); }
	)*
}

void ii_assigment() : 
{
	Token tBinding;
	Token tTargetIns;
		
	Queue<String> qLeftIns = new LinkedList<String>();
	
	int iLeftCount = 1;
	int iRightCount = 1; 
}
{
	<AT>tBinding=<SYMBOL>
	{ fg.createBindingPort(tBinding.image,jj_input_stream.getBeginLine()-1); qLeftIns.offer(tBinding.image); }
	(
		<COMA>
		<AT>tBinding=<SYMBOL>
		{ fg.createBindingPort(tBinding.image,jj_input_stream.getBeginLine()-1); qLeftIns.offer(tBinding.image); iLeftCount++; }
	)*
	<EQUAL>
	tTargetIns = <SYMBOL> 
	{ fg.bindBindingPort(qLeftIns.poll(),tTargetIns.image,jj_input_stream.getBeginLine()-1); }
	ii_call(tTargetIns)
	(
		<COMA>
		tTargetIns = <SYMBOL>  
		{ fg.bindBindingPort(qLeftIns.poll(),tTargetIns.image,jj_input_stream.getBeginLine()-1); }
		ii_call(tTargetIns)	
		{ iRightCount++; }
	)*
	{
		if ( iLeftCount!=iRightCount )
			throw new ParseException ( 
				"Wrong number of elements in component binding assigment, "+
				iLeftCount+" on the left side and "+
				iRightCount+" on the right side on line "+
				(jj_input_stream.getBeginLine()-1)
			);
	}	
}